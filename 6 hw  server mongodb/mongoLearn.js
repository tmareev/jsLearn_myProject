const mongo = require('mongodb');
const url = 'mongodb://127.0.0.1:27017';
const connection = mongo.connect(url, 
    {useNewUrlParser: true}, 
    onConnect,
);

// если мы передаем коллбек в другую ф-ю, то монго, в качестве первого аргумента 
// подставит эррор. И если эррор === null то будет выполнять дальше. 
// здесь мы явно написали первый аргумент, чтоб перейти дальше. 
// client - это некий объект для работы с монгой.Что-то типа document когда мы писали сайтик 
// с добавлениями тегов. 
function onConnect(err, client){
    // client.db('check') - выбираем базу данных, аналог use check.
    const db = client.db('check');
    const col = db.collection('users');


    /**********************ДОБАВЛЕНИЕ ЭЛЕМЕНТОВ********************************************************************* */
    // // добавляем запись (document). Обязательно это должен быть объект
    // let data1 = {name: 'Taras', age: 26};
    // let data2 = {name: 'Dasha', age: 23};
    // col.insertOne(data2, onInsert);
    // // добавляем несколько записей (documents) в коллекцию. Передавать нужно массив объектов
    // col.insertMany([data1, data2]);
    
    

    /**********************ПОИСК ЭЛЕМЕНТОВ  ПЕРВЫЙ СПОСОБ!!!!!! **************************************************************************** */
    // // поиск ВСЕХ элементов в бд. После чего сформируется указатель. Билет на то что можем взять. 
    // // А затем мы уже их формируем и считываем в onFound и onArrayConverted
    // col.find(onFound);
    // // // или можно написать поиск по точному значению но ничего не вписывать 
    // // col.find({}, onFound);

    // // поиск ОПРЕДЕЛЕННОГО элемента по точному значению 
    // // col.find({name: 'Taras'}, onFound);

    // //например у нас есть элемент {name: 'Ivan', xxx: [a, b, c]} и нам нужно
    // //найти его по b. Здесь найдутся все элементы у которых есть b в xxx:
    // col.find({
    //     xxx: 'b'
    // },onFound);

    // // так найдутся только те элементы у которых только одно значение b в ххх и все:
    // col.find({
    //     xxx: ['b']
    // },onFound);

    // //например у нас есть элемент {name: 'Ivan', xxx: [a, b, c]} и нам нужно
    // //найти только те элементы у которых b идет вторым в очереди массива ххх.
    // // Кавычки ('xxx.1')ставятся т.к. через точку без них будет неправильный запрос
    // col.find({
    //     'xxx.1': 'b'
    // },onFound);

    // // например у нас есть элемент {name: 'Ivan', xxx: {'0': a, '1': b, 'hoho: 'haha'}}
    // // и нам нужно найти только те элементы у которых b идет вторым в очереди 
    // // особого массива-объекта ххх:
    // col.find({
    //     'xxx.1': 'b'
    // },onFound);

    // // например у нас есть элемент {a: {b: {c: [1, 2, 3]}}}
    // // сможем найти его по 2:
    // col.find({
    //     'a.b.c': 2
    // },onFound);

    // // поиск по двум требованиям сразу. Тоесть выведется только тот элементу которого 
    // // age = 20 и xxx = a
    // col.find({
    //     age : 20, xxx: 'a'
    // },onFound);


    // /**********************ПОИСК ЭЛЕМЕНТОВ  ВТОРОЙ СПОСОБ!!!!!! **************************************************************************** */
    // // если мы в условии поиска используем объект {}, то это значит что 
    // // мы будем проводить поиск по оператору. Хотя это спорный момент, т.к.
    // // мы может хотим найти просто пустой объект. Поэтому внутри мы будем юзать $
    // col.find({
    //     age : {$ "что-то" : 20};
    // },onFound);

    // // операторы: lt - less than (меньше), eq - equal (равен), ne - not equal(не равен),
    // // ge - greater than(больше), gte - greater than or equal(больше или равно), 
    // // lte - less than or equal(меньше или равно), 
    // col.find({
    //     age : {$lt: 20}
    // },onFound);

    // // найти элемент который имеет или то или другое:
    // col.find({
    //     $or: [
    //         {age : 20},
    //         {name: 'Taras'}
    //     ]
    // },onFound);



    // // /**********************УДАЛЕНИЕ ЗАПИСЕЙ *******************************
    // // Здесь все работает также как при поиске.
    // // удалить самый первый элемент который подходит под условие:
    // col.deleteOne({
    //     age: 20
    // }, onDeleted)

    // // удалить все записи которые подходит под условие:
    // col.deleteMany({
    //     age: 20
    // }, onDeleted)



    // // /**********************UPDATING ЗАПИСЕЙ *******************************
    // передаем не один объект, а два. С помощью первого выбираем элемент,
    // с помощью второго меняем значение с помощью оператора $set или 
    // если такого свойства нету, то оно добавится
    // col.updateOne({age: 20}, {$set: {age: 25}}, console.log)
    
    // найти пропапйдетить и удалить одно из свойств элемента c помощью unset.
    // здесь удалится свойство ххх
    // col.updateMany({age: 20}, {$set: {age: 25}, $unset: {xxx: 1}}, onDeleted)



};

// здесь cursor это ссылка на то что мы ищем. Т.к. данных может быть очень много.
// пытаемся вывести данные в виде массива. Но toArray - это тоже promise, поэтому 
// в качестве параметра снова делаем колбек, чтобы данные успели сформирроваться и вывестись
function onFound(err, cursor){
    cursor.toArray(onArrayConverted);

    // **************Определение что отображать****************
    // // если мы хотим выводить только опредленные свойства из найденного объекта 
    // // юзаем метод project. В нем перечисляем какие свойства выводить а какие нет
    // // через true/false или 1/0. Они идентичны. Но id будет выводится всегда!
    // // Здесь выведется только id, name и age.Все остальное если оно есть, 
    // // будет проигнорировано
    // cursor.project({
    //     name: 1,
    //     age: 1
    // }).toArray(onArrayConverted);

    // // Здесь выведется все кроме name
    // cursor.project({
    //     name: 0,
    // }).toArray(onArrayConverted);


    // // *************************Сортировать****************
    // // например сортировать по имени
    // cursor.sort({name: 1}).toArray(onArrayConverted);


}
function onArrayConverted(err, data){
    console.log(data);
}


// вместо этих callback ф-й можно написать любую (например console.log). В качестве
// параметра будет передаваться объект-ссылка (типа Cursor и тд) к которой можно 
// применять разные методы.
// Выполнится с удаленными элементами(записями, documents)
function onDeleted(err, move){

}

// //  выполнится со вставленными элементами(записями, documents)
function onInsert(err, result){
    
}

// //  выполнится со проапдецченными элементами(записями, documents)
function onUpdated(err, action){

}